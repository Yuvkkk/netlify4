<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>文件下载与解密</title>
</head>
<body>
  <h1>从 Backblaze B2 下载并解密文件</h1>
  <label for="fileUrl">文件 URL:</label>
  <input type="text" id="fileUrl" size="50" placeholder="请输入 B2 文件 URL" /><br><br>
  <label for="keyInput">密钥 (Base64):</label>
  <textarea id="keyInput" rows="4" cols="50" placeholder="请输入上传时保存的密钥"></textarea><br><br>
  <button id="downloadButton" onclick="downloadAndDecrypt()">下载并解密</button>
  <p id="result"></p>
  <script>
    const CHUNK_SIZE = 8 * 1024 * 1024; // 8MB，与上传时的合并大小一致

    async function decryptChunk(chunk, keyBase64) {
      const keyBuffer = Uint8Array.from(atob(keyBase64), c => c.charCodeAt(0));
      const key = await crypto.subtle.importKey(
        "raw",
        keyBuffer,
        { name: "AES-GCM" },
        false,
        ["decrypt"]
      );

      const buffer = await chunk.arrayBuffer();
      const iv = buffer.slice(0, 12); // 前 12 字节是 IV
      const encryptedData = buffer.slice(12); // 剩余部分是加密数据 + 标签

      const decrypted = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv },
        key,
        encryptedData
      );
      return new Blob([decrypted]);
    }

    async function downloadAndDecrypt() {
      const downloadButton = document.getElementById("downloadButton");
      downloadButton.disabled = true;
      const resultElement = document.getElementById("result");
      resultElement.textContent = "开始下载...";

      const fileUrl = document.getElementById("fileUrl").value.trim();
      const keyBase64 = document.getElementById("keyInput").value.trim();

      if (!fileUrl || !keyBase64) {
        resultElement.textContent = "请输入文件 URL 和密钥";
        downloadButton.disabled = false;
        return;
      }

      try {
        // 获取文件大小
        const headResponse = await fetch(fileUrl, { method: "HEAD" });
        if (!headResponse.ok) throw new Error("无法获取文件信息");
        const fileSize = parseInt(headResponse.headers.get("Content-Length"), 10);
        console.log(`文件大小: ${fileSize} 字节`);

        const totalChunks = Math.ceil(fileSize / CHUNK_SIZE);
        console.log(`总分片数: ${totalChunks}`);
        const decryptedChunks = [];

        // 分片下载并解密
        for (let i = 0; i < totalChunks; i++) {
          const start = i * CHUNK_SIZE;
          const end = Math.min(start + CHUNK_SIZE - 1, fileSize - 1);
          console.log(`下载分片 ${i + 1}/${totalChunks}, 范围: ${start}-${end}`);

          const response = await fetch(fileUrl, {
            headers: { Range: `bytes=${start}-${end}` },
          });
          if (!response.ok) throw new Error(`下载分片 ${i + 1} 失败`);

          const chunk = await response.blob();
          console.log(`分片 ${i + 1} 下载完成，大小: ${chunk.size} 字节`);

          // 处理分片内的加密块
          const chunkBuffer = await chunk.arrayBuffer();
          const chunkSize = chunkBuffer.byteLength;
          const blockSize = 4 * 1024 * 1024 + 28; // 4MB + 28 字节
          const numBlocks = Math.ceil(chunkSize / blockSize);

          for (let j = 0; j < numBlocks; j++) {
            const blockStart = j * blockSize;
            const blockEnd = Math.min(blockStart + blockSize, chunkSize);
            const block = chunkBuffer.slice(blockStart, blockEnd);

            if (block.byteLength < 28) continue; // 小于 IV + 标签，跳过

            const blockBlob = new Blob([block]);
            const decryptedBlock = await decryptChunk(blockBlob, keyBase64);
            console.log(`分片 ${i + 1} 块 ${j + 1} 解密完成，大小: ${decryptedBlock.size} 字节`);
            decryptedChunks.push(decryptedBlock);
          }
        }

        // 合并解密后的块
        const decryptedFile = new Blob(decryptedChunks);
        console.log(`解密完成，总大小: ${decryptedFile.size} 字节`);

        // 创建下载链接
        const downloadUrl = URL.createObjectURL(decryptedFile);
        const a = document.createElement("a");
        a.href = downloadUrl;
        a.download = fileUrl.split("/").pop().replace(".enc", "");
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(downloadUrl);

        resultElement.textContent = "文件下载并解密成功！";
      } catch (error) {
        console.error("解密失败:", error.message);
        resultElement.textContent = `解密失败: ${error.message}`;
      }

      downloadButton.disabled = false;
    }
  </script>
</body>
</html>
